use self::command::Command;
use self::synchronize::construct_rdb;
use crate::config::Config;
use crate::resp::{resp_parser::RespParser, resp_serializer::serialize_resp_data, RespType};

use std::collections::HashMap;
use std::sync::Arc;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{Mutex, RwLock};
use tokio::task;
use tokio::time::{sleep, Duration};

pub mod command;
pub mod synchronize;

pub struct Redis {
    database: Arc<Mutex<HashMap<String, String>>>,
    config: Arc<Config>,
    listener: TcpListener,
    replica_connections: Arc<RwLock<Option<HashMap<i32, Arc<RwLock<TcpStream>>>>>>,
    master_connection: Option<Arc<RwLock<TcpStream>>>,
    // Replicas must maintain their connection to master, this is they will propagate changes
}

impl Redis {
    async fn handle_conn(&mut self, stream: Arc<RwLock<TcpStream>>) {
        let database: Arc<Mutex<HashMap<String, String>>> = Arc::clone(&self.database);
        let config = Arc::clone(&self.config);
        let replica_connections = Arc::clone(&self.replica_connections);
        task::spawn(async move {
            loop {
                // If a stream is a replica stream, don't automatically listen to it
                // We do have to listen until the handshake is complete though
                let stream_data: String;
                if !is_replica(Arc::clone(&replica_connections), Arc::clone(&stream)).await {
                    stream_data = match read_from_stream(Arc::clone(&stream)).await {
                        Some(x) => x,
                        None => break,
                    }
                } else {
                    break;
                }

                println!("====== Receiving new transmission ======");
                println!("{}", stream_data,);
                println!("====== End of new transmission ======");

                let mut parser = RespParser::new(stream_data, Arc::clone(&stream));
                let command = parser.parse_command();

                // If command is write and this is the master, propagate command to all replicas
                if config.is_master() && command.is_write() {
                    let replica_connections = replica_connections.read().await;
                    if let Some(ref connections) = *replica_connections {
                        for (_port, replica_stream) in connections.iter() {
                            println!("Found replica stream");
                            synchronize::propagate_command_to_replica(
                                Arc::clone(&replica_stream),
                                &command,
                            )
                            .await;
                        }
                    }
                }

                match command {
                    Command::Echo(message) => {
                        handle_echo(message, Arc::clone(&stream)).await;
                    }
                    Command::Ping => {
                        handle_ping(Arc::clone(&stream)).await;
                    }
                    Command::Set(key, value, expiry) => {
                        handle_set(
                            key,
                            value,
                            expiry,
                            Arc::clone(&stream),
                            Arc::clone(&database),
                        )
                        .await;
                    }
                    Command::Get(key) => {
                        handle_get(key, Arc::clone(&stream), Arc::clone(&database)).await;
                    }
                    Command::Info(arg) => {
                        handle_info(arg, Arc::clone(&config), Arc::clone(&stream)).await;
                    }
                    Command::ReplConf(_arg1, _arg2) => {
                        if !config.is_master() {
                            panic!("Recieving REPLCONF command as a replica, should exclusively be sent by replicas to masters");
                        }
                        handle_replconf(Arc::clone(&stream)).await;
                    }
                    Command::Psync(replication_id, offset) => {
                        if !config.is_master() {
                            panic!("Recieving PSYNC command as a replica, should exclusively be sent by replicas to masters");
                        }
                        handle_psync(
                            replication_id,
                            offset,
                            Arc::clone(&stream),
                            Arc::clone(&database),
                        )
                        .await;

                        use std::os::unix::io::AsRawFd;
                        let mut guard = replica_connections.write().await;
                        match *guard {
                            Some(ref mut connections) => {
                                let fd = stream.read().await.as_raw_fd();
                                let _ = connections.insert(fd, Arc::clone(&stream));
                            }
                            None => panic!("Master should have a hashmap dedicated to storing connections to replicas"),
                        }
                    }
                    _ => panic!("Unsupported Command"),
                };
            }
        });
    }
    async fn send_and_recieve(
        stream: Arc<RwLock<TcpStream>>,
        message: &str,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let mut stream = stream.write().await;
        // Write the message to the stream
        stream.write_all(message.as_bytes()).await?;
        stream.flush().await?;

        // Buffer to store the response
        let mut buf = [0; 1024];
        let n = stream.read(&mut buf).await?;

        // Convert the response to a String
        let response = String::from_utf8_lossy(&buf[..n]).to_string();
        Ok(response)
    }
    pub async fn perform_handshake(&mut self) {
        use crate::resp::RespType;
        if self.config.is_master() {
            return;
        }
        let ping: RespType =
            RespType::Array(vec![RespType::BulkString(Some(String::from("PING")))]);
        let repl_port = RespType::Array(vec![
            RespType::BulkString(Some(String::from("REPLCONF"))),
            RespType::BulkString(Some(String::from("listening-port"))),
            RespType::BulkString(Some(String::from(&format!("{}", self.config.port)))),
        ]);
        let repl_capa = RespType::Array(vec![
            RespType::BulkString(Some(String::from("REPLCONF"))),
            RespType::BulkString(Some(String::from("capa"))),
            RespType::BulkString(Some(String::from("psync2"))),
        ]);
        let psync = RespType::Array(vec![
            RespType::BulkString(Some(String::from("PSYNC"))),
            RespType::BulkString(Some(String::from("?"))),
            RespType::BulkString(Some(String::from("-1"))),
        ]);

        let serialized_ping = serialize_resp_data(ping);
        let serialized_repl_port = serialize_resp_data(repl_port);
        let serialized_repl_capa = serialize_resp_data(repl_capa);
        let serialized_psync = serialize_resp_data(psync);
        self.master_connection = match TcpStream::connect(format!(
            "{}:{}",
            self.config.master_host.as_ref().unwrap(),
            self.config.master_port.as_ref().unwrap()
        ))
        .await
        {
            Ok(x) => Some(x),
            Err(e) => panic!("{}", e),
        };

        let mut stream = Arc::clone(&self.master_connection.unwrap());
        let _ = Redis::send_and_recieve(Arc::clone(&stream), &serialized_ping).await;
        let _ = Redis::send_and_recieve(Arc::clone(&stream), &serialized_repl_port).await;
        let _ = Redis::send_and_recieve(Arc::clone(&stream), &serialized_repl_capa).await;r
        let stream_data = Redis::send_and_recieve(Arc::clone(stream), &serialized_psync)
            .await
            .expect("Failed to recieve repl_id from master at the end of handshake");
        // We read up to CRLF and then everything after is the contents of the RDB file
        // if we don't read as much as we expect, we read again, until we do
        // then the stream is empty enough
        println!("====== Recieiving Psync Response from Master ======");
        println!("{}", stream_data);
        println!("====== End of Psync Response from Master ==========");
        let mut parser = RespParser::new(stream_data, Arc::clone(&stream));
        // I will assume this first read contains all of the fullresync command
        let repl_id = parser.read_data_till_crlf();
    }

    pub async fn listen(&mut self) -> Result<Self, Box<(dyn std::error::Error + 'static)>> {
        if !self.config.is_master() {
            let master_connection = {
                match &self.master_connection {
                    Some(x) => Arc::clone(&x),
                    None => panic!("Expected to have master connection on replica"),
                }
            };
            self.handle_conn(master_connection).await;
        }
        loop {
            let (stream, _) = self.listener.accept().await?;
            println!("New stream connected to master: {:?}", stream);
            let stream = Arc::new(RwLock::new(stream));
            self.handle_conn(Arc::clone(&stream)).await;
        }
    }

    pub async fn new(
        config: Arc<Config>,
        listener: TcpListener,
    ) -> Result<Self, Box<(dyn std::error::Error + 'static)>> {
        let connections: Arc<RwLock<Option<HashMap<i32, Arc<RwLock<TcpStream>>>>>> =
            match config.is_master() {
                true => Arc::new(RwLock::new(Some(HashMap::new()))),
                false => Arc::new(RwLock::new(None)),
            };
        Ok(Redis {
            database: Arc::new(Mutex::new(HashMap::new())),
            config,
            listener,
            replica_connections: connections,
            master_connection: None,
        })
    }
}

async fn read_from_stream(stream: Arc<RwLock<TcpStream>>) -> Option<String> {
    let mut stream = stream.write().await;
    let mut buffer: [u8; 1024] = [0; 1024];
    match stream.read(&mut buffer).await {
        Ok(0) => None,
        Ok(_) => Some(String::from_utf8(buffer.to_vec()).expect("Expected valid utf-8 sequence")),
        Err(e) => panic!("Stream returned error: {:?}", e),
    }
}

async fn is_replica(
    replica_connections: Arc<RwLock<Option<HashMap<i32, Arc<RwLock<TcpStream>>>>>>,
    stream: Arc<RwLock<TcpStream>>,
) -> bool {
    use std::os::unix::io::AsRawFd;

    let replica_connections = replica_connections.write().await;
    if let Some(ref connections) = *replica_connections {
        let stream = stream.read().await;
        let stream_fd = stream.as_raw_fd();
        for (replica_fd, _replica_stream) in connections.iter() {
            if stream_fd == *replica_fd {
                return true;
            }
        }
    }
    false
}

async fn handle_echo(message: String, stream: Arc<RwLock<TcpStream>>) {
    let response = String::from(&format!("${}\r\n{}\r\n", message.len(), message));
    let mut stream = stream.write().await;
    let _ = stream.write_all(response.as_bytes()).await;
}

async fn handle_ping(stream: Arc<RwLock<TcpStream>>) {
    let response = String::from("+PONG\r\n");
    let mut stream = stream.write().await;
    let _ = stream.write_all(response.as_bytes()).await;
}

async fn handle_set(
    key: String,
    value: String,
    expiry: Option<u64>,
    stream: Arc<RwLock<TcpStream>>,
    db: Arc<Mutex<HashMap<String, String>>>,
) {
    {
        let mut db = db.lock().await;
        db.insert(key.clone(), value);
    }
    if let Some(delay_millis) = expiry {
        let key_clone = key.clone();
        let db_clone = Arc::clone(&db);
        tokio::spawn(async move {
            sleep(Duration::from_millis(delay_millis)).await;
            let mut db = db_clone.lock().await;
            db.remove(&key_clone);
        });
    }
    let response = String::from("+OK\r\n");
    let mut stream = stream.write().await;
    let _ = stream.write_all(response.as_bytes()).await;
}

async fn handle_get(
    key: String,
    stream: Arc<RwLock<TcpStream>>,
    db: Arc<Mutex<HashMap<String, String>>>,
) {
    let db = db.lock().await;
    let response = match db.get(&key) {
        Some(y) => String::from(format!("${}\r\n{}\r\n", y.len(), y)),
        None => String::from("$-1\r\n"),
    };
    let mut stream = stream.write().await;
    let _ = stream.write_all(response.as_bytes()).await;
}

async fn handle_info(_arg: String, config: Arc<Config>, stream: Arc<RwLock<TcpStream>>) {
    let response = match config.role.as_str() {
        "master" => serialize_resp_data(RespType::BulkString(
            format!(
                "role:{}\nmaster_replid:{}\nmaster_repl_offset:{}\n",
                config.role,
                config.master_replid.as_ref().unwrap(),
                config.master_repl_offset.as_ref().unwrap()
            )
            .into(),
        )),
        "slave" => {
            serialize_resp_data(RespType::BulkString(format!("role:{}", config.role).into()))
        }
        _ => panic!("Redis instance must be either slave or master"),
    };
    let mut stream = stream.write().await;
    let _ = stream.write_all(response.as_bytes()).await;
}

async fn handle_replconf(stream: Arc<RwLock<TcpStream>>) {
    let response = String::from("+OK\r\n");
    let mut stream = stream.write().await;
    let _ = stream.write_all(response.as_bytes()).await;
}

async fn handle_psync(
    _replication_id: String,
    _offset: String,
    stream: Arc<RwLock<TcpStream>>,
    db: Arc<Mutex<HashMap<String, String>>>,
) {
    {
        let mut stream = stream.write().await;

        let repl_id = "8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb";
        let response = String::from(&format!("+FULLRESYNC {} 0\r\n", repl_id));
        let (length, binary) = construct_rdb(Arc::clone(&db));

        let _ = stream.write_all(response.as_bytes()).await;
        let _ = stream.write_all(length.as_bytes()).await;
        let _ = stream.write_all(&binary).await;
    }
}
